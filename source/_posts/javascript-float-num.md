---
title: javascript浮点数精度问题
date: 2019-10-10 12:09:59
tags: JavaScript
---
### 浮点数陷阱
原文：https://zhuanlan.zhihu.com/ne-fe

众所周知，JavaScript 浮点数运算时经常遇到会 0.000000001 和 0.999999999 这样奇怪的结果，如 0.1+0.2=0.30000000000000004、1-0.9=0.09999999999999998，很多人知道这是浮点数误差问题，但具体就说不清楚了。本文帮你理清这背后的原理以及解决方案，还会向你解释JS中的大数危机和四则运算中会遇到的坑。
<!--more -->
### 浮点数的储存

首先要搞清楚 JavaScript 如何存储小数。和其它语言如 Java 和 Python 不同，JavaScript 中所有数字包括整数和小数都只有一种类型 — Number。它的实现遵循 IEEE 754 标准，使用 64 位固定长度来表示，也就是标准的 double 双精度浮点数（相关的还有float 32位单精度）。

这样的存储结构优点是可以归一化处理整数和小数，节省存储空间。

64位比特又可分为三个部分：

* 符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数
* 指数位E：中间的 11 位存储指数（exponent），用来表示次方数
* 尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零

![图片](/images/javascript_float_num/demo1.png)

实际数字就可以用以下公式来计算：
![图片](/images/javascript_float_num/demo2.png)

公式推导过程见维基百科[wiki](https://zh.wikipedia.org/wiki/%E9%9B%99%E7%B2%BE%E5%BA%A6%E6%B5%AE%E9%BB%9E%E6%95%B8)

### 为什么0.1+0.2 =0.30000000000000004?
0.1 转成二进制表示为 0.0001100110011001100(1100循环)，1.100110011001100x2^-4，所以 E=-4+1023=1019；M 舍去首位的1，得到 100110011...。
转化成十进制后为 0.100000000000000005551115123126，因此就出现了浮点误差。
接着0.1+0.2计算步骤为
```
0.00011001100110011001100110011001100110011001100110011010 +
0.0011001100110011001100110011001100110011001100110011010 =
0.0100110011001100110011001100110011001100110011001100111
// 转成十进制正好是 0.30000000000000004
```
因为 mantissa 固定长度是 52 位，再加上省略的一位，最多可以表示的数是 2^53=9007199254740992，对应科学计数尾数是 9.007199254740992，这也是 JS 最多能表示的精度，如果整数大于 9007199254740992 会出现什么情况呢？
由于 E 最大值是 1023，所以最大可以表示的整数是 2^1024 - 1，这就是能表示的最大整数。但你并不能这样计算这个数字，因为从 2^1024 开始就变成了 Infinity
```
Math.pow(2, 1023)
//8.98846567431158e+307

//Math.pow(2, 1024)
Infinity
```
那么对于 (2^53, 2^63) 之间的数会出现什么情况呢？

* (2^53, 2^54) 之间的数会两个选一个，只能精确表示偶数
* (2^54, 2^55) 之间的数会四个选一个，只能精确表示4个倍数
* ... 依次跳过更多2的倍数
下面这张图能很好的表示 JavaScript 中浮点数和实数（Real Number）之间的对应关系
![real number](/images/javascript_float_num/demo3.jfif)

要想解决大数的问题你可以引用第三方库 bignumber.js，原理是把所有数字当作字符串，重新实现了计算逻辑，缺点是性能比原生的差很多

### toPrecision vs toFixed

数据处理时，这两个函数很容易混淆。它们的共同点是把数字转成字符串供展示使用。注意在计算的中间过程不要使用，只用于最终结果。

不同点就需要注意一下

* toPrecision 是处理精度，精度是从左至右第一个不为0的数开始数起。
* toFixed 是小数点后指定位数取整，从小数点开始数起。

两者都能对多余数字做凑整处理，也有些人用 toFixed 来做四舍五入，但一定要知道它是有 Bug 的。

如：1.005.toFixed(2) 返回的是 1.00 而不是 1.01。

原因： 1.005 实际对应的数字是 1.00499999999999989，在四舍五入时全部被舍去！

解法：使用专业的四舍五入函数 Math.round() 来处理。但 Math.round(1.005 * 100) / 100 还是不行，因为 1.005 * 100 = 100.49999999999999。还需要把乘法和除法精度误差都解决后再使用 Math.round。

### 解决方法

* https://github.com/dt-fe/number-precision
* BigInt
* Number.EPSILON,表示 1 与Number可表示的大于 1 的最小的浮点数之间的差值。如果两个数的差值小于这个，就认为这两个数相等